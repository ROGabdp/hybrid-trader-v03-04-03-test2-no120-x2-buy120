# -*- coding: utf-8 -*-
"""
================================================================================
V4 ÁÑ°ÊøæÁ∂≤ Rolling LSTM ÂõûÊ∏¨ËÖ≥Êú¨ (No Filter Rolling LSTM Backtest)
================================================================================
Âú®ÂõûÊ∏¨ÈñãÂßãÂâçÈáçÊñ∞Ë®ìÁ∑¥ LSTM Ê®°ÂûãÔºåË®ìÁ∑¥Êà™Ê≠¢Êó•Êúü = ÂõûÊ∏¨ÈñãÂßãÊó•Êúü - 1 Â§©„ÄÇ
ÈÄôÊ®£ÂèØ‰ª•Ê®°Êì¨ÁúüÂØ¶‰∫§ÊòìÊÉÖÂ¢ÉÔºöÊØèÊ¨°ÂõûÊ∏¨ÈÉΩ‰ΩøÁî®Âè™ÂåÖÂê´Ê≠∑Âè≤Ë≥áÊñôÁöÑ LSTM Ê®°Âûã„ÄÇ

Ëàá backtest_v4_no_filter.py ÁöÑÂ∑ÆÁï∞Ôºö
- Âú®ËºâÂÖ• LSTM Ê®°ÂûãÂâçÔºåÂÖàÈáçÊñ∞Ë®ìÁ∑¥ T+1, T+5, T+20 Ê®°Âûã
- Ë®ìÁ∑¥Ë≥áÊñôÊà™Ê≠¢Êó• = ÂõûÊ∏¨ÈñãÂßãÊó• - 1 Â§©
- Âº∑Âà∂Ê∏ÖÈô§ÁâπÂæµÂø´Âèñ‰∏¶ÈáçÊñ∞Ë®àÁÆó

LSTM Ë®ìÁ∑¥Ë®≠ÂÆö (ÂèÉËÄÉ daily_ops_v4.py)Ôºö
- T+1:  ÈÅéÂéª 2000 Â§©
- T+5:  ÈÅéÂéª 2200 Â§©
- T+20: ÈÅéÂéª 2400 Â§©
- split_ratio: 0.99 (ÂÖ®ÈáèË®ìÁ∑¥)

‰ΩúËÄÖÔºöPhil Liang (Generated by Claude)
Êó•ÊúüÔºö2025-12-14
================================================================================
"""

import os
import sys
import pickle
import argparse
import subprocess
import glob
from datetime import datetime, timedelta

# Windows UTF-8 Ë®≠ÂÆö
if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8')

os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from stable_baselines3 import PPO

# ‰∏≠ÊñáÂ≠óÂûãË®≠ÂÆö
plt.rcParams['font.sans-serif'] = ['Microsoft JhengHei', 'SimHei', 'Arial Unicode MS']
plt.rcParams['axes.unicode_minus'] = False

# =============================================================================
# Ë®≠ÂÆö
# =============================================================================
PROJECT_PATH = os.path.dirname(os.path.abspath(__file__))
V4_MODELS_PATH = os.path.join(PROJECT_PATH, 'models_hybrid_v4')
RESULTS_PATH = os.path.join(PROJECT_PATH, 'results_backtest_v4_no_filter_rolling_lstm')
CACHE_DIR = os.path.join(PROJECT_PATH, 'data', 'processed')

# LSTM Ë®ìÁ∑¥ËÖ≥Êú¨
SCRIPT_1D = 'twii_model_registry_multivariate.py'
SCRIPT_5D = 'twii_model_registry_5d.py'
SCRIPT_20D = 'twii_model_registry_20d.py'

# LSTM Ë®ìÁ∑¥Ë®≠ÂÆö (ÂèÉËÄÉ daily_ops_v4.py)
TRAIN_DAYS_1D = 2000   # T+1 Ê®°ÂûãË®ìÁ∑¥Â§©Êï∏
TRAIN_DAYS_5D = 2200   # T+5 Ê®°ÂûãË®ìÁ∑¥Â§©Êï∏
TRAIN_DAYS_20D = 2400  # T+20 Ê®°ÂûãË®ìÁ∑¥Â§©Êï∏
TRAIN_SPLIT_RATIO = "0.99"  # ÂÖ®ÈáèË®ìÁ∑¥

DEFAULT_START_DATE = '2023-01-01'
DEFAULT_END_DATE = None
INITIAL_CAPITAL = 1_000_000


def parse_args():
    """Ëß£ÊûêÂëΩ‰ª§ÂàóÂèÉÊï∏"""
    parser = argparse.ArgumentParser(
        description='V4 Rolling LSTM ÂõûÊ∏¨ËÖ≥Êú¨ - ÊØèÊ¨°ÂõûÊ∏¨ÂâçÈáçÊñ∞Ë®ìÁ∑¥ LSTM',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
‰ΩøÁî®ÁØÑ‰æã:
  python backtest_v4_rolling_lstm.py                           # ‰ΩøÁî®È†êË®≠Êó•Êúü (2023-01-01 Ëá≥‰ªä)
  python backtest_v4_rolling_lstm.py --start 2022-01-01        # Âæû 2022-01-01 ÈñãÂßãÂõûÊ∏¨
  python backtest_v4_rolling_lstm.py --start 2023-06-01 --end 2024-06-30  # ÊåáÂÆöÂÆåÊï¥Êó•ÊúüÁØÑÂúç
        '''
    )
    parser.add_argument(
        '--start', 
        type=str, 
        default=DEFAULT_START_DATE,
        help=f'ÂõûÊ∏¨ÈñãÂßãÊó•Êúü (YYYY-MM-DD Ê†ºÂºèÔºåÈ†êË®≠: {DEFAULT_START_DATE})'
    )
    parser.add_argument(
        '--end', 
        type=str, 
        default=DEFAULT_END_DATE,
        help='ÂõûÊ∏¨ÁµêÊùüÊó•Êúü (YYYY-MM-DD Ê†ºÂºèÔºåÈ†êË®≠: ÊúÄÊñ∞Ë≥áÊñô)'
    )
    parser.add_argument(
        '--skip-lstm-train',
        action='store_true',
        help='Ë∑≥ÈÅé LSTM ÈáçË®ì (‰ΩøÁî®ÁèæÊúâÊ®°ÂûãÔºåÁî®Êñº debug)'
    )
    return parser.parse_args()


def train_lstm_models(train_end_date: str):
    """
    Ë®ìÁ∑¥ LSTM Ê®°Âûã (T+1, T+5, T+20)
    
    Args:
        train_end_date: Ë®ìÁ∑¥Êà™Ê≠¢Êó•Êúü (= ÂõûÊ∏¨ÈñãÂßãÊó• - 1 Â§©)
    
    Returns:
        True if successful, False otherwise
    """
    print("\n" + "=" * 60)
    print("üìö Step 0: LSTM Ê®°ÂûãÈáçÊñ∞Ë®ìÁ∑¥")
    print("=" * 60)
    
    end_dt = datetime.strptime(train_end_date, '%Y-%m-%d')
    start_1d = (end_dt - timedelta(days=TRAIN_DAYS_1D)).strftime('%Y-%m-%d')
    start_5d = (end_dt - timedelta(days=TRAIN_DAYS_5D)).strftime('%Y-%m-%d')
    start_20d = (end_dt - timedelta(days=TRAIN_DAYS_20D)).strftime('%Y-%m-%d')
    
    print(f"  Ë®ìÁ∑¥Êà™Ê≠¢Êó•: {train_end_date}")
    print(f"  T+1 Ë®ìÁ∑¥ÊúüÈñì:  {start_1d} ~ {train_end_date} ({TRAIN_DAYS_1D} Â§©)")
    print(f"  T+5 Ë®ìÁ∑¥ÊúüÈñì:  {start_5d} ~ {train_end_date} ({TRAIN_DAYS_5D} Â§©)")
    print(f"  T+20 Ë®ìÁ∑¥ÊúüÈñì: {start_20d} ~ {train_end_date} ({TRAIN_DAYS_20D} Â§©)")
    print(f"  Split Ratio: {TRAIN_SPLIT_RATIO}")
    
    # 1. Ë®ìÁ∑¥ T+1 Ê®°Âûã
    print(f"\n[Training] T+1 Model...")
    script_1d_path = os.path.join(PROJECT_PATH, SCRIPT_1D)
    cmd_1d = [
        sys.executable, script_1d_path, "train",
        "--start", start_1d,
        "--end", train_end_date,
        "--split_ratio", TRAIN_SPLIT_RATIO
    ]
    try:
        subprocess.run(cmd_1d, check=True, timeout=600, cwd=PROJECT_PATH)
        print("[Training] ‚úÖ T+1 Ë®ìÁ∑¥ÂÆåÊàê")
    except subprocess.CalledProcessError as e:
        print(f"[Error] T+1 Ë®ìÁ∑¥Â§±Êïó: {e}")
        return False
    except FileNotFoundError:
        print(f"[Error] Êâæ‰∏çÂà∞Ë®ìÁ∑¥ËÖ≥Êú¨: {script_1d_path}")
        return False
    
    # 2. Ë®ìÁ∑¥ T+5 Ê®°Âûã
    print(f"\n[Training] T+5 Model...")
    script_5d_path = os.path.join(PROJECT_PATH, SCRIPT_5D)
    cmd_5d = [
        sys.executable, script_5d_path, "train",
        "--start", start_5d,
        "--end", train_end_date,
        "--split_ratio", TRAIN_SPLIT_RATIO
    ]
    try:
        subprocess.run(cmd_5d, check=True, timeout=600, cwd=PROJECT_PATH)
        print("[Training] ‚úÖ T+5 Ë®ìÁ∑¥ÂÆåÊàê")
    except subprocess.CalledProcessError as e:
        print(f"[Error] T+5 Ë®ìÁ∑¥Â§±Êïó: {e}")
        return False
    except FileNotFoundError:
        print(f"[Error] Êâæ‰∏çÂà∞Ë®ìÁ∑¥ËÖ≥Êú¨: {script_5d_path}")
        return False
    
    # 3. Ë®ìÁ∑¥ T+20 Ê®°Âûã
    print(f"\n[Training] T+20 Model...")
    script_20d_path = os.path.join(PROJECT_PATH, SCRIPT_20D)
    cmd_20d = [
        sys.executable, script_20d_path, "train",
        "--start", start_20d,
        "--end", train_end_date,
        "--split_ratio", TRAIN_SPLIT_RATIO
    ]
    try:
        subprocess.run(cmd_20d, check=True, timeout=600, cwd=PROJECT_PATH)
        print("[Training] ‚úÖ T+20 Ë®ìÁ∑¥ÂÆåÊàê")
    except subprocess.CalledProcessError as e:
        print(f"[Error] T+20 Ë®ìÁ∑¥Â§±Êïó: {e}")
        return False
    except FileNotFoundError:
        print(f"[Error] Êâæ‰∏çÂà∞Ë®ìÁ∑¥ËÖ≥Êú¨: {script_20d_path}")
        return False
    
    # 4. Ê∏ÖÈô§ÁâπÂæµÂø´Âèñ (Âº∑Âà∂‰ΩøÁî®Êñ∞ÁöÑ LSTM Ê®°ÂûãÈáçÊñ∞Ë®àÁÆó)
    print("\n[Cache] Ê∏ÖÈô§ÁâπÂæµÂø´Âèñ...")
    cache_files = glob.glob(os.path.join(CACHE_DIR, "*.pkl"))
    for f in cache_files:
        try:
            os.remove(f)
            print(f"  Âà™Èô§: {os.path.basename(f)}")
        except:
            pass
    
    print("\n[Done] LSTM Ë®ìÁ∑¥ÂÆåÊàêÔºÅ")
    return True


# =============================================================================
# ÁÑ°ÊøæÁ∂≤ÂõûÊ∏¨Âô® (Âæû backtest_v4_no_filter.py Ë§áË£Ω)
# =============================================================================
class NoFilterBacktester:
    """
    ÁÑ°ÊøæÁ∂≤ÂõûÊ∏¨Âô®ÔºöÊØèÂ§©ÈÉΩËÄÉÊÖÆË≤∑ÈÄ≤Ë®äËôüÔºå‰∏çÂèó Signal_Buy_Filter ÈôêÂà∂
    """
    def __init__(self, buy_model, sell_model, initial_capital=1_000_000):
        self.buy_model = buy_model
        self.sell_model = sell_model
        self.initial_capital = initial_capital
        self.trades = []
        self.equity_curve = []
        self.buy_signals = []
        self.sell_signals = []
        self.daily_confidence = []
    
    def run(self, df: pd.DataFrame, feature_cols: list) -> dict:
        """Âü∑Ë°åÁÑ°ÊøæÁ∂≤ÂõûÊ∏¨"""
        capital = self.initial_capital
        position = None
        
        features = df[feature_cols].values.astype(np.float32)
        close_prices = df['Close'].values
        dates = df.index
        
        print(f"[Backtest] ÂõûÊ∏¨ÊúüÈñì: {dates[0].strftime('%Y-%m-%d')} ~ {dates[-1].strftime('%Y-%m-%d')}")
        print(f"[Backtest] Ë≥áÊñôÁ≠ÜÊï∏: {len(df)}")
        print(f"[Backtest] ÂàùÂßãË≥áÈáë: ${capital:,.0f}")
        print("[Backtest] Ê®°Âºè: Rolling LSTM (ÁÑ°ÊøæÁ∂≤)")
        
        for i in range(len(df)):
            date = dates[i]
            price = close_prices[i]
            
            if position is not None:
                current_value = capital + position['shares'] * price
            else:
                current_value = capital
            self.equity_curve.append({'date': date, 'value': current_value})
            
            obs = np.nan_to_num(features[i], nan=0.0, posinf=1.0, neginf=-1.0)
            
            if position is not None:
                hold_days = i - position['buy_idx']
                current_return = price / position['buy_price']
                
                sell_obs = np.concatenate([obs, [current_return]]).astype(np.float32).reshape(1, -1)
                action, _ = self.sell_model.predict(sell_obs, deterministic=True)
                
                sell_obs_tensor = self.sell_model.policy.obs_to_tensor(sell_obs)[0]
                sell_probs = self.sell_model.policy.get_distribution(sell_obs_tensor).distribution.probs.detach().cpu().numpy()[0]
                sell_confidence = float(sell_probs[1]) if action[0] == 1 else float(sell_probs[0])
                
                self.daily_confidence.append({
                    'date': date, 'status': 'holding', 'price': price,
                    'buy_conf': None, 'sell_conf': sell_confidence,
                    'sell_action': 'SELL' if action[0] == 1 else 'HOLD',
                    'current_return': current_return
                })
                
                stop_loss = current_return < 0.92
                ai_sell = action[0] == 1
                should_sell = ai_sell or stop_loss
                
                if should_sell:
                    sell_value = position['shares'] * price
                    profit = sell_value - position['shares'] * position['buy_price']
                    capital += sell_value
                    
                    if stop_loss:
                        sell_reason = 'stop_loss'
                    else:
                        sell_reason = 'ai_signal'
                    
                    self.trades.append({
                        'buy_date': position['buy_date'],
                        'buy_price': position['buy_price'],
                        'buy_confidence': position.get('buy_confidence', 0),
                        'sell_date': date,
                        'sell_price': price,
                        'sell_confidence': sell_confidence,
                        'sell_reason': sell_reason,
                        'return': current_return - 1,
                        'profit': profit,
                        'hold_days': hold_days
                    })
                    self.sell_signals.append((date, price, sell_confidence))
                    position = None
            
            elif position is None:
                buy_obs = obs.reshape(1, -1)
                action, _ = self.buy_model.predict(buy_obs, deterministic=True)
                
                buy_obs_tensor = self.buy_model.policy.obs_to_tensor(buy_obs)[0]
                buy_probs = self.buy_model.policy.get_distribution(buy_obs_tensor).distribution.probs.detach().cpu().numpy()[0]
                buy_confidence = float(buy_probs[1]) if action[0] == 1 else float(buy_probs[0])
                
                self.daily_confidence.append({
                    'date': date, 'status': 'idle', 'price': price,
                    'buy_conf': buy_confidence, 'sell_conf': None,
                    'buy_action': 'BUY' if action[0] == 1 else 'WAIT',
                    'current_return': None
                })
                
                if action[0] == 1:
                    invest_amount = capital * 0.9
                    shares = int(invest_amount / price)
                    
                    if shares > 0:
                        cost = shares * price
                        capital -= cost
                        
                        position = {
                            'shares': shares,
                            'buy_price': price,
                            'buy_date': date,
                            'buy_idx': i,
                            'buy_confidence': buy_confidence
                        }
                        self.buy_signals.append((date, price, buy_confidence))
        
        return self._calculate_metrics(df)
    
    def _calculate_metrics(self, df: pd.DataFrame) -> dict:
        """Ë®àÁÆóÁ∏æÊïàÊåáÊ®ô"""
        if not self.equity_curve:
            return {}
        
        equity_df = pd.DataFrame(self.equity_curve)
        equity_df['date'] = pd.to_datetime(equity_df['date'])
        equity_df.set_index('date', inplace=True)
        
        initial = self.initial_capital
        final = equity_df['value'].iloc[-1]
        total_return = (final - initial) / initial
        
        days = (equity_df.index[-1] - equity_df.index[0]).days
        years = days / 365.0
        annualized_return = (1 + total_return) ** (1 / years) - 1 if years > 0 else 0
        
        daily_returns = equity_df['value'].pct_change().dropna()
        if len(daily_returns) > 0 and daily_returns.std() > 0:
            sharpe = (daily_returns.mean() * 252 - 0.02) / (daily_returns.std() * np.sqrt(252))
        else:
            sharpe = 0
        
        rolling_max = equity_df['value'].cummax()
        drawdown = (equity_df['value'] - rolling_max) / rolling_max
        max_drawdown = drawdown.min()
        
        if self.trades:
            wins = sum(1 for t in self.trades if t['return'] > 0)
            win_rate = wins / len(self.trades)
            avg_return = np.mean([t['return'] for t in self.trades])
            avg_hold_days = np.mean([t['hold_days'] for t in self.trades])
        else:
            win_rate = 0
            avg_return = 0
            avg_hold_days = 0
        
        return {
            'initial_capital': initial,
            'final_value': final,
            'total_return': total_return,
            'annualized_return': annualized_return,
            'sharpe_ratio': sharpe,
            'max_drawdown': max_drawdown,
            'total_trades': len(self.trades),
            'win_rate': win_rate,
            'avg_return': avg_return,
            'avg_hold_days': avg_hold_days,
            'equity_df': equity_df
        }


# =============================================================================
# ‰∏ªÁ®ãÂºè
# =============================================================================
def main():
    args = parse_args()
    
    try:
        start_date = pd.Timestamp(args.start)
    except Exception as e:
        print(f"[Error] ÁÑ°ÊïàÁöÑÈñãÂßãÊó•ÊúüÊ†ºÂºè: {args.start}")
        sys.exit(1)
    
    end_date = None
    if args.end:
        try:
            end_date = pd.Timestamp(args.end)
        except Exception as e:
            print(f"[Error] ÁÑ°ÊïàÁöÑÁµêÊùüÊó•ÊúüÊ†ºÂºè: {args.end}")
            sys.exit(1)
        
        if end_date <= start_date:
            print(f"[Error] ÁµêÊùüÊó•Êúü ({args.end}) ÂøÖÈ†àÂ§ßÊñºÈñãÂßãÊó•Êúü ({args.start})")
            sys.exit(1)
    
    print("=" * 60)
    print("V4 ÁÑ°ÊøæÁ∂≤ Rolling LSTM ÂõûÊ∏¨ (No Filter + Retrain LSTM)")
    print("=" * 60)
    print(f"  üìÖ ÂõûÊ∏¨ÈñãÂßãÊó•Êúü: {args.start}")
    print(f"  üìÖ ÂõûÊ∏¨ÁµêÊùüÊó•Êúü: {args.end if args.end else 'ÊúÄÊñ∞Ë≥áÊñô'}")
    
    # LSTM Ë®ìÁ∑¥Êà™Ê≠¢Êó• = ÂõûÊ∏¨ÈñãÂßãÊó• - 1 Â§©
    train_end_date = (start_date - timedelta(days=1)).strftime('%Y-%m-%d')
    print(f"  üìö LSTM Ë®ìÁ∑¥Êà™Ê≠¢Êó•: {train_end_date}")
    
    os.makedirs(RESULTS_PATH, exist_ok=True)
    
    # =========================================================================
    # Step 0: Ë®ìÁ∑¥ LSTM Ê®°Âûã
    # =========================================================================
    if not args.skip_lstm_train:
        if not train_lstm_models(train_end_date):
            print("[Error] LSTM Ë®ìÁ∑¥Â§±ÊïóÔºåÁÑ°Ê≥ïÁπºÁ∫åÂõûÊ∏¨")
            sys.exit(1)
    else:
        print("\n[Skip] LSTM ÈáçË®ì (--skip-lstm-train)")
    
    # =========================================================================
    # ËºâÂÖ•Ê®°Âûã
    # =========================================================================
    print("\n[Model] ËºâÂÖ• V4 Ê®°Âûã...")
    buy_path = os.path.join(V4_MODELS_PATH, 'ppo_buy_twii_final.zip')
    sell_path = os.path.join(V4_MODELS_PATH, 'ppo_sell_twii_final.zip')
    
    if not os.path.exists(buy_path):
        print(f"[Error] Ê®°Âûã‰∏çÂ≠òÂú®: {buy_path}")
        print("Ë´ãÂÖàÂü∑Ë°å train_v4_models.py")
        sys.exit(1)
    
    buy_model = PPO.load(buy_path)
    sell_model = PPO.load(sell_path)
    print("  ‚úÖ Ê®°ÂûãËºâÂÖ•ÊàêÂäü")
    
    # =========================================================================
    # ËºâÂÖ•/Ë®àÁÆóÁâπÂæµË≥áÊñô
    # =========================================================================
    print("\n[Data] Ê∫ñÂÇôÂõûÊ∏¨Ë≥áÊñô...")
    import ptrl_hybrid_system as hybrid
    import twii_model_registry_multivariate as lstm_1d_module
    import twii_model_registry_5d as lstm_5d_module
    import twii_model_registry_20d as lstm_20d_module
    
    # Ë®àÁÆóÂâõÂâõË®ìÁ∑¥ÁöÑÊ®°ÂûãÁöÑ train_start Âíå train_end
    end_dt = datetime.strptime(train_end_date, '%Y-%m-%d')
    start_1d = (end_dt - timedelta(days=TRAIN_DAYS_1D)).strftime('%Y-%m-%d')
    start_5d = (end_dt - timedelta(days=TRAIN_DAYS_5D)).strftime('%Y-%m-%d')
    start_20d = (end_dt - timedelta(days=TRAIN_DAYS_20D)).strftime('%Y-%m-%d')
    
    # Áõ¥Êé•ËºâÂÖ•ÂâõÂâõË®ìÁ∑¥Â•ΩÁöÑ LSTM Ê®°Âûã (‰∏ç‰ΩøÁî® select_best_modelÔºåÈÅøÂÖçÈÅ∏Âà∞ R¬≤ ËºÉÈ´òÁöÑËàäÊ®°Âûã)
    print(f"\n[LSTM] ËºâÂÖ•ÂâõË®ìÁ∑¥ÂÆåÊàêÁöÑÊ®°Âûã (train_end: {train_end_date})")
    
    try:
        model_1d, scaler_feat_1d, scaler_tgt_1d, meta_1d = lstm_1d_module.load_artifacts(
            start_1d, train_end_date)
        print(f"  ‚úÖ T+1 Model: {start_1d} ~ {train_end_date}")
    except Exception as e:
        print(f"[Error] ÁÑ°Ê≥ïËºâÂÖ• T+1 Ê®°Âûã: {e}")
        sys.exit(1)
    
    try:
        model_5d, scaler_feat_5d, scaler_tgt_5d, meta_5d = lstm_5d_module.load_artifacts(
            start_5d, train_end_date)
        print(f"  ‚úÖ T+5 Model: {start_5d} ~ {train_end_date}")
    except Exception as e:
        print(f"[Error] ÁÑ°Ê≥ïËºâÂÖ• T+5 Ê®°Âûã: {e}")
        sys.exit(1)
    
    try:
        model_20d, scaler_feat_20d, scaler_tgt_20d, meta_20d = lstm_20d_module.load_artifacts(
            start_20d, train_end_date)
        print(f"  ‚úÖ T+20 Model: {start_20d} ~ {train_end_date}")
    except Exception as e:
        print(f"[Error] ÁÑ°Ê≥ïËºâÂÖ• T+20 Ê®°Âûã: {e}")
        sys.exit(1)
    
    # Ê≥®ÂÖ•Âà∞ hybrid Ê®°ÁµÑ
    hybrid._LSTM_MODELS.update({
        'model_1d': model_1d, 'scaler_feat_1d': scaler_feat_1d,
        'scaler_tgt_1d': scaler_tgt_1d, 'meta_1d': meta_1d,
        'model_5d': model_5d, 'scaler_feat_5d': scaler_feat_5d,
        'scaler_tgt_5d': scaler_tgt_5d, 'meta_5d': meta_5d,
        'model_20d': model_20d, 'scaler_feat_20d': scaler_feat_20d,
        'scaler_tgt_20d': scaler_tgt_20d, 'meta_20d': meta_20d,
        'loaded': True
    })
    
    # Ë®àÁÆóÁâπÂæµ (Áî±ÊñºÂø´ÂèñÂ∑≤Ê∏ÖÈô§ÔºåÊúÉ‰ΩøÁî®Êñ∞ÁöÑ LSTM Ê®°Âûã)
    print("  [Compute] ‰ΩøÁî®Êñ∞Ë®ìÁ∑¥ÁöÑ LSTM Ë®àÁÆóÁâπÂæµ...")
    twii_raw = hybrid._load_local_twii_data(start_date="2000-01-01")
    twii_full_df = hybrid.calculate_features(twii_raw, twii_raw, ticker="^TWII", use_cache=False)  # [v4.0] Âº∑Âà∂ÈáçÁÆó
    
    # ÂàÜÂâ≤ÂõûÊ∏¨Ë≥áÊñô
    twii_backtest_df = twii_full_df[twii_full_df.index >= start_date]
    if end_date:
        twii_backtest_df = twii_backtest_df[twii_backtest_df.index <= end_date]
    
    if len(twii_backtest_df) == 0:
        print(f"[Error] ÊåáÂÆöÁöÑÊó•ÊúüÁØÑÂúçÂÖßÊ≤íÊúâË≥áÊñô")
        sys.exit(1)
    
    print(f"  ÂõûÊ∏¨ÊúüÈñì: {twii_backtest_df.index[0].strftime('%Y-%m-%d')} ~ {twii_backtest_df.index[-1].strftime('%Y-%m-%d')}")
    print(f"  Ë≥áÊñôÁ≠ÜÊï∏: {len(twii_backtest_df)}")
    
    # =========================================================================
    # Âü∑Ë°åÂõûÊ∏¨
    # =========================================================================
    print("\n[Backtest] ÈñãÂßã Rolling LSTM ÂõûÊ∏¨...")
    backtester = NoFilterBacktester(buy_model, sell_model, INITIAL_CAPITAL)
    metrics = backtester.run(twii_backtest_df, hybrid.FEATURE_COLS)
    
    # =========================================================================
    # Ë®àÁÆó Benchmark Á∏æÊïà
    # =========================================================================
    equity_df = metrics['equity_df']
    bench_slice = twii_full_df.loc[equity_df.index[0]:equity_df.index[-1]]['Close']
    bench_normalized = bench_slice / bench_slice.iloc[0] * INITIAL_CAPITAL
    
    bench_initial = INITIAL_CAPITAL
    bench_final = bench_normalized.iloc[-1]
    bench_total_return = (bench_final - bench_initial) / bench_initial
    
    days = (bench_slice.index[-1] - bench_slice.index[0]).days
    years = days / 365.0
    bench_annualized = (1 + bench_total_return) ** (1 / years) - 1 if years > 0 else 0
    
    bench_daily_returns = bench_normalized.pct_change().dropna()
    if len(bench_daily_returns) > 0 and bench_daily_returns.std() > 0:
        bench_sharpe = (bench_daily_returns.mean() * 252 - 0.02) / (bench_daily_returns.std() * np.sqrt(252))
    else:
        bench_sharpe = 0
    
    bench_rolling_max = bench_normalized.cummax()
    bench_drawdown = (bench_normalized - bench_rolling_max) / bench_rolling_max
    bench_max_dd = bench_drawdown.min()
    
    # =========================================================================
    # Âç∞Âá∫Á∏æÊïà
    # =========================================================================
    print("\n" + "=" * 70)
    print("Performance Comparison: V4 Rolling LSTM vs Buy & Hold")
    print("=" * 70)
    print(f"{'Metric':<20} {'V4 Rolling LSTM':>20} {'Buy & Hold':>20}")
    print("-" * 70)
    print(f"{'Initial Capital':<20} ${metrics['initial_capital']:>18,.0f} ${bench_initial:>18,.0f}")
    print(f"{'Final Value':<20} ${metrics['final_value']:>18,.0f} ${bench_final:>18,.0f}")
    print(f"{'Total Return':<20} {metrics['total_return']*100:>19.2f}% {bench_total_return*100:>19.2f}%")
    print(f"{'Annualized Return':<20} {metrics['annualized_return']*100:>19.2f}% {bench_annualized*100:>19.2f}%")
    print(f"{'Sharpe Ratio':<20} {metrics['sharpe_ratio']:>20.2f} {bench_sharpe:>20.2f}")
    print(f"{'Max Drawdown':<20} {metrics['max_drawdown']*100:>19.2f}% {bench_max_dd*100:>19.2f}%")
    print("-" * 70)
    print(f"{'Trades':<20} {metrics['total_trades']:>20}")
    print(f"{'Win Rate':<20} {metrics['win_rate']*100:>19.1f}%")
    print(f"{'Avg Return/Trade':<20} {metrics['avg_return']*100:>19.2f}%")
    print(f"{'Avg Hold Days':<20} {metrics['avg_hold_days']:>20.1f}")
    print("=" * 70)
    
    # =========================================================================
    # Ë¶ñË¶∫Âåñ
    # =========================================================================
    fig, axes = plt.subplots(2, 1, figsize=(14, 10))
    
    ax1 = axes[0]
    ax1.plot(equity_df.index, equity_df['value'], label='V4 Rolling LSTM', color='blue', linewidth=2)
    ax1.plot(bench_normalized.index, bench_normalized.values, 
             label='^TWII Buy & Hold', color='gray', linewidth=1.5, alpha=0.7)
    
    date_range_str = f"{twii_backtest_df.index[0].strftime('%Y-%m-%d')} ~ {twii_backtest_df.index[-1].strftime('%Y-%m-%d')}"
    ax1.set_title(f'V4 Rolling LSTM vs Buy & Hold ({date_range_str})', fontsize=14)
    ax1.set_ylabel('Portfolio Value ($)')
    ax1.legend(loc='upper left')
    ax1.grid(True, alpha=0.3)
    
    # LSTM Ë®ìÁ∑¥Ë®≠ÂÆöÊ®ôË®ª
    lstm_info = (
        f"LSTM Training:\n"
        f"  T+1:  {meta_1d['train_start']} ~ {meta_1d['train_end']}\n"
        f"  T+5:  {meta_5d['train_start']} ~ {meta_5d['train_end']}\n"
        f"  T+20: {meta_20d['train_start']} ~ {meta_20d['train_end']}"
    )
    props = dict(boxstyle='round,pad=0.5', facecolor='lightyellow', alpha=0.9, edgecolor='orange')
    ax1.text(0.02, 0.97, lstm_info, transform=ax1.transAxes, fontsize=8,
             verticalalignment='top', horizontalalignment='left',
             bbox=props, family='monospace')
    
    ax2 = axes[1]
    price_slice = twii_backtest_df['Close']
    ax2.plot(price_slice.index, price_slice.values, label='^TWII Close', color='black', linewidth=1)
    
    if backtester.buy_signals:
        buy_dates, buy_prices, buy_confs = zip(*backtester.buy_signals)
        ax2.scatter(buy_dates, buy_prices, marker='^', color='red', s=100, label='Buy', zorder=5)
        for dt, pr, conf in backtester.buy_signals:
            ax2.annotate(f'{conf:.0%}', (dt, pr), textcoords="offset points", 
                        xytext=(0, 10), ha='center', fontsize=7, color='red', fontweight='bold')
    
    if backtester.sell_signals:
        sell_dates, sell_prices, sell_confs = zip(*backtester.sell_signals)
        ax2.scatter(sell_dates, sell_prices, marker='v', color='green', s=100, label='Sell', zorder=5)
        for dt, pr, conf in backtester.sell_signals:
            ax2.annotate(f'{conf:.0%}', (dt, pr), textcoords="offset points", 
                        xytext=(0, -15), ha='center', fontsize=7, color='green', fontweight='bold')
    
    ax2.set_title('Trade Signals with Confidence (Rolling LSTM)', fontsize=14)
    ax2.set_ylabel('Price')
    ax2.set_xlabel('Date')
    ax2.legend(loc='upper left')
    ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    start_str = twii_backtest_df.index[0].strftime('%Y%m%d')
    end_str = twii_backtest_df.index[-1].strftime('%Y%m%d')
    save_path = os.path.join(RESULTS_PATH, f'backtest_v4_no_filter_rolling_lstm_{start_str}_{end_str}.png')
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    print(f"\n[Output] Chart saved: {save_path}")
    plt.close()
    
    # =========================================================================
    # ÂÑ≤Â≠òÁµêÊûú
    # =========================================================================
    metrics_df = pd.DataFrame({
        'Metric': ['Initial_Capital', 'Final_Value', 'Total_Return_Pct', 'Annualized_Return_Pct', 
                   'Sharpe_Ratio', 'Max_Drawdown_Pct', 'Trades', 'Win_Rate_Pct', 'Avg_Return_Pct', 'Avg_Hold_Days'],
        'V4_Rolling_LSTM': [metrics['initial_capital'], metrics['final_value'], metrics['total_return']*100,
                          metrics['annualized_return']*100, metrics['sharpe_ratio'], metrics['max_drawdown']*100,
                          metrics['total_trades'], metrics['win_rate']*100, metrics['avg_return']*100, metrics['avg_hold_days']],
        'Buy_Hold': [bench_initial, bench_final, bench_total_return*100, bench_annualized*100,
                     bench_sharpe, bench_max_dd*100, 'N/A', 'N/A', 'N/A', 'N/A']
    })
    metrics_path = os.path.join(RESULTS_PATH, f'metrics_v4_no_filter_rolling_lstm_{start_str}_{end_str}.csv')
    metrics_df.to_csv(metrics_path, index=False, encoding='utf-8-sig')
    print(f"[Output] Metrics CSV: {metrics_path}")
    
    if backtester.trades:
        trades_df = pd.DataFrame(backtester.trades)
        trades_path = os.path.join(RESULTS_PATH, f'trades_v4_no_filter_rolling_lstm_{start_str}_{end_str}.csv')
        trades_df.to_csv(trades_path, index=False)
        print(f"[Output] ‰∫§ÊòìÊòéÁ¥∞: {trades_path}")
    
    if backtester.daily_confidence:
        conf_df = pd.DataFrame(backtester.daily_confidence)
        conf_path = os.path.join(RESULTS_PATH, f'daily_confidence_v4_no_filter_rolling_lstm_{start_str}_{end_str}.csv')
        conf_df.to_csv(conf_path, index=False)
        print(f"[Output] ÊØèÊó•‰ø°ÂøÉÂ∫¶: {conf_path}")
    
    print("\n" + "=" * 60)
    print("‚úÖ Rolling LSTM ÂõûÊ∏¨ÂÆåÊàêÔºÅ")
    print("=" * 60)


if __name__ == "__main__":
    main()
